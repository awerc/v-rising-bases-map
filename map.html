<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>V: RISING — Карта</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="https://fonts.googleapis.com/css2?family=Shantell+Sans:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="mask-icon" href="safari-pinned-tab.svg" color="#0e161d">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #1e1e1e;
      color: #eee;
      font-family: 'Shantell Sans', sans-serif;
    }
    * {
      box-sizing: border-box;
    }
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
    #markerList {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 300px;
      background: rgba(30, 30, 30, 0.95);
      border-left: 2px solid #444;
      overflow-y: auto;
      padding: 10px;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.7);
      z-index: 999;
      font-size: 16px;
    }
    #playerNamesInput {
      width: 100%;
      height: 80px;
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #555;
      padding: 10px;
      resize: none;
    }
    .marker-item {
      padding: 10px;
      border-bottom: 1px solid #444;
      cursor: pointer;
    }
    .marker-title {
      font-weight: bold;
      color: #ffcccc;
    }
    .marker-level {
      font-size: 14px;
      color: #aaa;
    }
    .marker-players {
      display: flex;
      flex-direction: column;
    }
    .hours {
      user-select: none;
      font-family: monospace;
      color: #ccc;
    }
    .marker-players span.matched {
      color: #d35252;
      font-weight: bold;
    }
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 300px;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    #modal form {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 6px;
      width: 300px;
    }
    #modal input,
    #modal textarea,
    #modal select {
      width: 100%;
      margin-bottom: 10px;
      background: #1e1e1e;
      color: white;
      border: 1px solid #444;
      padding: 5px;
    }
    button.close-modal {
      float: right;
      background: #d35252;
      color: white;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 18px;
    }

    .ol-overlay-container  {
      pointer-events: none !important;
    }
    #popup {
      background: rgba(30, 30, 30, 0.95);
      color: #fff;
      padding: 10px;
      border-radius: 6px;
      font-family: 'Shantell Sans', cursive;
    }
    #popup strong {
      color: #ffcccc;
    }
    #popup button {
      pointer-events: all;
      margin-top: 5px;
      background: #d35252;
      color: white;
      border: none;
      padding: 4px 8px;
      font-size: 14px;
      cursor: pointer;
      margin-right: 5px;
    }
    #popup button:nth-of-type(2) {
      background: #52d37b;
    }
    .icon-level-0 { opacity: 1; }
    .icon-level-1 { opacity: 0.8; }
    .icon-level-2 { opacity: 0.6; }
    .icon-level-3 { opacity: 0.4; }
    .icon-level-4 { opacity: 0.2; }
    .autocomplete-items {
      position: absolute;
      border: 1px solid #555;
      border-top: none;
      z-index: 9999;
      background: rgba(30, 30, 30, 0.95);
      max-height: 200px;
      overflow-y: auto;
      width: 260px;
      font-family: sans-serif;
      font-size: 14px;
    }
    .autocomplete-items div {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #555;
    }
    .autocomplete-items div:hover {
      background-color: rgba(43, 43, 43, 0.95);
    }
    .online {
      position: relative;
    }
    .online:after {
      display: block;
      content: '';
      width: 6px;
      height: 6px;
      background: #46d91c;
      position: absolute;
      top: 1px;
      right: -4px;
      border-radius: 100%;
    }
  </style>
</head>
<body>
<div id="map"></div>
<aside id="markerList">
  <label class="full-width"><h3>Players list</h3>
    <textarea id="playerNamesInput" oninput="autoCompletePlayers(this)" placeholder="Player1, Player2..."></textarea>
    <div id="autocomplete-list" class="autocomplete-items"></div>
  </label>
  <hr />
  <h3>Markers</h3>
  <div id="markersContainer"></div>
</aside>
<div id="modal">
  <form id="markerForm">
    <button type="button" class="close-modal">&times;</button>
    <h4>Add / Edit</h4>
    <label>Level:
      <select name="level">
        <option value="I">I</option>
        <option value="II">II</option>
        <option value="III">III</option>
        <option value="IV">IV</option>
        <option value="V">V</option>
      </select>
    </label>
    <label>Title:
      <input type="text" name="title" />
    </label>
    <label>Description:
      <textarea name="description"></textarea>
    </label>
    <label>Players:
      <input type="text" id="modal-players-input" name="players" oninput="autoCompletePlayers(this)" />
      <div id="autocomplete-modal-list" class="autocomplete-items"></div>
    </label>
    <button type="submit">Save</button>
  </form>
</div>
<div id="popup" class="ol-popup">
  <div class="popup-content"></div>
  <a href="#" class="ol-popup-closer"></a>
</div>

<script src="https://cdn.jsdelivr.net/npm/ol@v10.5.0/dist/ol.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v10.5.0/ol.css">
<script>
  const API_ENDPOINT = 'https://api.battlemetrics.com'
  const SERVER = '33218693'
  const API_URL = `${API_ENDPOINT}/servers/${SERVER}`
  const imageBounds = [0, 0, 6080, 6080];
  const imageUrl = 'map.webp';
  const GIST_ID = '5c5b1173184b3389531fe6235001b800';
  const GITHUB_TOKEN = localStorage.getItem('gh_token');
  const FILE_NAME = 'rising.json';
  let currentMarker = null;
  let currentCoordinates = null;
  let activePlayers = [];
  let allPlayers = [];
  var vectorSource = new ol.source.Vector();

  const size = 6080; // Размер вашей карты в пикселях
  const extent = [0, 0, size, size];
  const projection = new ol.proj.Projection({
    code: 'PIXEL',
    units: 'pixels',
    extent: extent
  });

  const map = new ol.Map({
    target: 'map',
    layers: [
      new ol.layer.Image({
        source: new ol.source.ImageStatic({
          url: imageUrl,
          imageExtent: extent, // Укажите тот же extent, что и у проекции
          projection: projection // Используйте пользовательскую проекцию
        })
      }),
      new ol.layer.Vector({
        source: vectorSource,
        extent: extent, // Укажите тот же extent, что и у проекции
        projection: projection // Используйте пользовательскую проекцию
        // updateWhileInteracting: true
      })
    ],
    view: new ol.View({
      projection: projection, // Укажите пользовательскую проекцию
      center: ol.extent.getCenter(extent), // Центр в пиксельных координатах
      zoom: -3,
      minZoom: -5,
      maxZoom: 7,
      extent: [-1000, -1000, 8060, 8060] // Ограничьте область карты
    }),
    controls: ol.control.defaults.defaults().extend([
      new ol.control.Zoom(),
      new ol.control.Attribution()
    ])
  });

  const container = document.getElementById('popup');
  const content = container.querySelector('.popup-content');
  const overlay = new ol.Overlay({
    element: container,
    autoPan: true,
    autoPanAnimation: { duration: 250 }
  });
  map.addOverlay(overlay);
  overlay.setPosition(undefined);


  function getIconStyle(level, matches = 0) {
    return new ol.style.Style({
      image: new ol.style.Icon({
        src: ['V','IV','III','II','I'].includes(level?.toUpperCase())
                ? `${level.toUpperCase()}.svg`
                : 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
        opacity: 1 - matches * 0.2,
        scale: 1,
      })
    });
  }


  function showModal(coordinates, markerData = null) {
    currentCoordinates = coordinates; // [x, y]
    currentMarker = markerData ? markerData.feature : null;

    markerForm.level.value = markerData?.level || 'I';
    markerForm.title.value = markerData?.title || '';
    markerForm.description.value = markerData?.description || '';
    document.getElementById('modal-players-input').value = markerData?.players?.join(', ') || '';
    modal.style.display = 'flex';
    setTimeout(() => map.updateSize(), 200);
  }

  markerForm.addEventListener('submit', function(e) {
    e.preventDefault();
    const data = {
      level: this.level.value,
      title: this.title.value.trim(),
      description: this.description.value.trim(),
      players: parsePlayers(document.getElementById('modal-players-input').value).map(player =>
              allPlayers.find(x => x.name.toLowerCase() === player.toLowerCase())?.name ?? player
      ),
      lat: currentCoordinates[1],
      lng: currentCoordinates[0]
    };
    if (currentMarker) {
      updateMarker(currentMarker, data);
    } else {
      addMarker(data);
    }
    modal.style.display = 'none';
    applyPlayerFilter();
    saveMarkersToGist();
  });


  document.querySelector('.close-modal').addEventListener('click', () => {
    modal.style.display = 'none';
    map.updateSize();
  });


  function parsePlayers(str) {
    return str.split(/[,\n]/)
            .map(p => p.trim())
            .filter(Boolean);
  }


  function addMarker(data) {
    if (typeof data.lat !== 'number' || typeof data.lng !== 'number') {
      console.error("Некорректные координаты метки", data);
      return;
    }

    // Проверьте, что координаты в пределах карты
    if (data.lng < 0 || data.lng > size || data.lat < 0 || data.lat > size) {
      console.error("Маркер за пределами карты", data);
      return;
    }

    // Координаты в пиксельной проекции: [x, y]
    const coordinates = [data.lng, data.lat];
    const feature = new ol.Feature(new ol.geom.Point(coordinates));

    console.log('======getIconStyle(data.level)', feature)
    feature.setStyle(getIconStyle(data.level));
    feature.set('data', {
      level: data.level,
      title: data.title,
      description: data.description,
      players: data.players,
      lat: data.lat,
      lng: data.lng
    });

    vectorSource.addFeature(feature);
    createPopup(feature);
    return feature;
  }
  function updateMarker(feature, newData) {
    const coordinates = feature.getGeometry().getCoordinates();
    feature.setStyle(getIconStyle(newData.level));
    feature.setProperties({
      data: {
        level: newData.level,
        title: newData.title,
        description: newData.description,
        players: newData.players,
        lat: coordinates[1],
        lng: coordinates[0]
      }
    });
    createPopup(feature, newData);
    saveMarkersToGist();
  }


  function createPopup(feature) {
    const data = feature.get('data');
    const coordinates = feature.getGeometry().getCoordinates();
    console.log('======coordinates', coordinates)
    const currentPosition = overlay.getPosition();
    if (currentPosition && currentPosition[0] === coordinates[0] && currentPosition[1] === coordinates[1]) {
      overlay.setPosition(undefined);
      return
    }

    const popupContent = `
      <div><strong>${data.title}</strong></div>
      <div>${data.description}</div>
      <div class="marker-players">
        ${data.players.map(p => {
      const isMatch = activePlayers.includes(p.toLowerCase());
      const player = allPlayers.find(x => x.name.toLowerCase() === p.toLowerCase());
      const text = `<span class=${player?.online ? "online" : ""}>${p}</span>` + (player ? ` <span class="hours">${Number((player?.value/60/60).toFixed(2))}h</span>` : '');
      return `<span class=${isMatch ? "matched" : ""}>${text}</span>`;
    }).join('') || '-'}
      </div>
      <button onclick="removeMarker(null, ${coordinates[0]}, ${coordinates[1]})">Delete</button>
      <button onclick="editMarker(${coordinates[0]}, ${coordinates[1]})">Edit</button>
    `;

    content.innerHTML = popupContent;
    overlay.setPosition(coordinates);
  }

  map.on('click', function(evt) {
    const feature = map.forEachFeatureAtPixel(evt.pixel, function(feature) {
      return feature;
    });

    if (feature) {
      createPopup(feature);
    } else {
      const coordinates = evt.coordinate; // [x, y] в пользовательской проекции
      showModal(coordinates);
      overlay.setPosition(undefined)
    }
  });

  map.on('pointermove', function (evt) {
    const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
      return feature;
    });

    // Если наводим на маркер — курсор pointer
    if (feature) {
      map.getTargetElement().style.cursor = 'pointer';
    } else {
      // Иначе — стандартный курсор
      map.getTargetElement().style.cursor = 'grab';
    }
  });


  window.editMarker = function(lng, lat) {
    const coordinates = [lng, lat];
    vectorSource.getFeaturesAtCoordinate(coordinates).forEach(function(feature) {
      const data = feature.get('data');
      showModal(coordinates, {
        feature: feature,
        level: data.level,
        title: data.title,
        description: data.description,
        players: data.players
      });
    });
  };


  window.removeMarker = function(btn, lng, lat) {
    const coordinates = [lng, lat];
    vectorSource.getFeaturesAtCoordinate(coordinates).forEach(function(feature) {
      vectorSource.removeFeature(feature);
    });
    saveMarkersToGist();
    const parent = btn?.closest('.marker-item');
    if (parent) parent.remove();
    overlay.setPosition(undefined);
  };


  function getMarkersFromMap() {
    const markers = [];
    vectorSource.forEachFeature(function(feature) {
      const data = feature.get('data');
      const geometry = feature.getGeometry();
      const coords = geometry.getCoordinates(); // [x, y]

      markers.push({
        level: data.level,
        title: data.title,
        description: data.description,
        players: data.players,
        lat: coords[1],  // y
        lng: coords[0]   // x
      });
    });
    return markers;
  }


  function renderMarkerList() {
    const markersContainer = document.getElementById('markersContainer');
    markersContainer.innerHTML = '';
    const markers = getMarkersFromMap();
    markers
        .slice()
        .sort((a, b) => b.players.filter(p => allPlayers.find(x => x.name.toLowerCase() === p.toLowerCase())?.online).length - a.players.filter(p => allPlayers.find(x => x.name.toLowerCase() === p.toLowerCase())?.online).length)
        .forEach(m => {
      const div = document.createElement('div');
      div.className = 'marker-item';
      div.innerHTML = `
        <div class="marker-level">[ ${m.level} ] <span class="marker-title">${m.title}</span></div>
        <div class="marker-players">
          ${m.players.map(p => {
        const isMatch = activePlayers.includes(p.toLowerCase());
        const player = allPlayers.find(x => x.name.toLowerCase() === p.toLowerCase());
        const text = `<span class=${player?.online ? "online" : ""}>${p}</span>` + (player ? ` <span class="hours">${Number((player?.value/60/60).toFixed(2))}h</span>` : '');
        return `<span class=${isMatch ? "matched" : ""}>${text}</span>`;
      }).join('') || '-'}
        </div>`;
      div.onclick = () => {
        // Переводим пиксельные координаты в центр карты
        map.getView().animate({
          center: [m.lng, m.lat], // [x, y]
          zoom: 4
        });

        // Открытие попапа
        const features = vectorSource.getFeaturesAtCoordinate([m.lng, m.lat]);
        if (features.length > 0) {
          const feature = features[0];
          createPopup(feature);
        }
      };
      markersContainer.appendChild(div);
    });
  }


  async function saveMarkersToGist() {
    let markers = getMarkersFromMap()
    markers = markers.filter((marker, index) => index <= markers.findIndex(m => m.lat === marker.lat && m.lng === marker.lng));
    if (!GITHUB_TOKEN) {
      localStorage.setItem('mapMarkers', JSON.stringify(markers));
      return;
    }
    const payload = {
      description: 'V: RISING Map Markers',
      public: false,
      files: {}
    };
    payload.files[FILE_NAME] = {
      content: JSON.stringify(markers, null, 2)
    };
    try {
      const res = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
        method: 'PATCH',
        headers: {
          Authorization: `token ${GITHUB_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });
      if (res.status === 200) {
        renderMarkerList();
      }
    } catch (e) {
      console.error('Ошибка сохранения в Gist', e);
    }
  }


  async function loadMarkersFromGist() {
    try {
      const res = await fetch(`https://api.github.com/gists/${GIST_ID}`);
      if (res.ok) {
        const json = await res.json();
        const raw = json.files[FILE_NAME]?.content;
        if (raw) {
          const markers = JSON.parse(raw);
          markers.forEach(m => {
            if (typeof m.lat === 'number' && typeof m.lng === 'number') {
              addMarker(m);
            }
          });
        }
      }
    } catch (e) {
      console.error(e, 'Не удалось загрузить из Gist');
    }
    const localMarkers = JSON.parse(localStorage.getItem('mapMarkers'));
    if (localMarkers) {
      localMarkers.forEach(m => {
        if (typeof m.lat === 'number' && typeof m.lng === 'number') {
          addMarker(m);
        }
      });
    }
    overlay.setPosition(undefined);
    renderMarkerList();
  }


  function applyPlayerFilter() {
    activePlayers = parsePlayers(document.getElementById('playerNamesInput').value).map(x => x.toLowerCase());
    console.log('======activePlayers', activePlayers)
    vectorSource.forEachFeature(function(feature) {
      const data = feature.get('data');
      const matches = data.players.filter(p => activePlayers.includes(p.toLowerCase()));
      console.log('======matches', matches)
      feature.setStyle(getIconStyle(data.level, matches.length));
    });
    renderMarkerList();
  }


  async function loadPlayerList() {
    try {
      const end = new Date();
      end.setUTCHours(0,0,0,0);
      const start = new Date(end);
      start.setUTCMonth(start.getUTCMonth() - 1);
      const period = `${start.toISOString()}:${end.toISOString()}`
      const online = await fetch(`${API_URL}?include=session&fields[session]=start,stop,name`).then(x => x.json()).then(response => response.included.filter(x => x.type ==='session' && !x.attributes.stop).map(x => x.attributes.name));
      allPlayers = (await Promise.all([
        fetch(`${API_URL}/relationships/leaderboards/time?page[size]=100&page[offset]=0&page[rel]=prev&filter[period]=${period}`).then(r => r.json().then(j => j.data.map(p => p.attributes))),
        fetch(`${API_URL}/relationships/leaderboards/time?page[size]=100&page[offset]=100&page[rel]=prev&filter[period]=${period}`).then(r => r.json().then(j => j.data.map(p => p.attributes))),
        fetch(`${API_URL}/relationships/leaderboards/time?page[size]=100&page[offset]=200&page[rel]=prev&filter[period]=${period}`).then(r => r.json().then(j => j.data.map(p => p.attributes)))
      ])).flat().map(x => ({...x, online: online.includes(x.name)}));
      renderMarkerList();
    } catch (e) {
      console.error('Ошибка загрузки списка игроков', e);
    }
  }


  function autoCompletePlayers(inputElement) {
    const val = inputElement.value.trim();
    const container = inputElement.nextElementSibling;
    container.innerHTML = "";
    if (!val) {
      applyPlayerFilter();
      return;
    }
    const currentList = val.split(',').map(s => s.trim());
    const last = currentList.pop().toLowerCase();
    const matches = allPlayers.filter(p =>
            p.name.toLowerCase().startsWith(last) &&
            !currentList.map(x => x.toLowerCase()).includes(p.name.toLowerCase())
    );
    matches.forEach(match => {
      const item = document.createElement("div");
      item.textContent = match.name;
      item.onclick = () => {
        const newValue = [...currentList, match.name].join(", ");
        inputElement.value = newValue + ", ";
        inputElement.focus();
        container.innerHTML = "";
        applyPlayerFilter();
      };
      container.appendChild(item);
    });
    applyPlayerFilter()
  }


  document.addEventListener("click", function(e) {
    const list = document.getElementById("autocomplete-list");
    const modalList = document.getElementById("autocomplete-modal-list");
    if (!e.target.closest('#playerNamesInput')) list.innerHTML = "";
    if (!e.target.closest('#modal-players-input')) modalList.innerHTML = "";
  });

  document.addEventListener('keydown', event => {
    if (event.key === "Escape") {
      modal.style.display = 'none';
      overlay.setPosition(undefined);
    }
  });



  window.addEventListener('load', () => {
    loadPlayerList().then(() => {
      loadMarkersFromGist();
    });
    window.addEventListener('resize', () => map.updateSize());
  });
</script>
</body>
</html>