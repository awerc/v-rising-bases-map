<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>V: RISING — Карта</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <link href="https://fonts.googleapis.com/css2?family=Shantell+Sans:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
  <link rel="mask-icon" href="safari-pinned-tab.svg" color="#0e161d">
  <link rel="icon" type="image/x-icon" href="favicon.ico">

  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #1e1e1e;
      color: #eee;
    }

    * {
      font-family: 'Shantell Sans', sans-serif;
      box-sizing: border-box;
    }

    .leaflet-container {
      background-color: #1e1e1e;
    }

    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    #markerList {
      position: absolute;
      right: 0;
      top: 0;
      bottom: 0;
      width: 300px;
      background: rgba(30, 30, 30, 0.95);
      border-left: 2px solid #444;
      overflow-y: auto;
      padding: 10px;
      box-shadow: -2px 0 5px rgba(0, 0, 0, 0.7);
      z-index: 999;
      font-size: 16px;
    }

    #playerNamesInput {
      width: 100%;
      height: 80px;
      background: #2a2a2a;
      color: #fff;
      border: 1px solid #555;
      padding: 10px;
      resize: none;
    }
    .marker-item {
      padding: 10px;
      border-bottom: 1px solid #444;
      cursor: pointer;
    }
    .marker-item:hover {
      background-color: #2c2c2c;
    }
    .marker-title {
      font-weight: bold;
      color: #ffcccc;
    }
    .marker-level {
      font-size: 14px;
      color: #aaa;
    }
    .marker-players span.matched {
      color: red;
      font-weight: bold;
    }
    #modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 300px;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    #modal form {
      background: #2a2a2a;
      padding: 20px;
      border-radius: 6px;
      width: 300px;
    }
    #modal input,
    #modal textarea,
    #modal select {
      width: 100%;
      margin-bottom: 10px;
      background: #1e1e1e;
      color: white;
      border: 1px solid #444;
      padding: 5px;
    }
    button.close-modal {
      float: right;
      background: #d35252;
      color: white;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 18px;
    }
    label.full-width {
      display: block;
      margin-top: 10px;
    }
    .leaflet-popup-content-wrapper {
      background: rgba(30, 30, 30, 0.95);
      color: #fff;
      padding: 10px;
      border-radius: 6px;
      font-family: 'Shantell Sans', cursive;
    }
    .leaflet-popup-tip {
      background: rgba(30, 30, 30, 0.95);
    }
    .leaflet-popup-content strong {
      color: #ffcccc;
    }
    .leaflet-popup-content button {
      margin-top: 5px;
      background: #d35252;
      color: white;
      border: none;
      padding: 4px 8px;
      font-size: 14px;
      cursor: pointer;
      margin-right: 5px;
    }
    .leaflet-popup-content button:nth-child(2) {
      background: #52d37b;
    }
    .icon-level-0 { opacity: 1; }
    .icon-level-1 { opacity: 0.8; }
    .icon-level-2 { opacity: 0.6; }
    .icon-level-3 { opacity: 0.4; }
    .icon-level-4 { opacity: 0.2; }

    .autocomplete-items {
      position: absolute;
      border: 1px solid #555;
      border-top: none;
      z-index: 9999;
      background: rgba(30, 30, 30, 0.95);
      max-height: 200px;
      overflow-y: auto;
      width: 260px;
      font-family: sans-serif;
      font-size: 14px;
    }
    .autocomplete-items div {
      padding: 8px;
      cursor: pointer;
      border-bottom: 1px solid #555;
    }
    .autocomplete-items div:hover {
      background-color: rgba(43, 43, 43, 0.95);
    }
  </style>
</head>
<body>

<div id="map"></div>

<aside id="markerList">
  <h3>Players list</h3>
  <label class="full-width">Список игроков (через запятую):
    <textarea id="playerNamesInput" oninput="autoCompletePlayers(this)" placeholder="Player1, Player2..."></textarea>
    <div id="autocomplete-list" class="autocomplete-items"></div>
  </label>

  <hr />

  <h3>Markers</h3>
  <div id="markersContainer"></div>
</aside>

<!-- Модальное окно -->
<div id="modal">
  <form id="markerForm">
    <button type="button" class="close-modal">&times;</button>
    <h4>Add / Edit</h4>
    <label>Level:
      <select name="level">
        <option value="I">I</option>
        <option value="II">II</option>
        <option value="III">III</option>
        <option value="IV">IV</option>
        <option value="V">V</option>
      </select>
    </label>
    <label>Title:
      <input type="text" name="title" />
    </label>
    <label>Description:
      <textarea name="description"></textarea>
    </label>
    <label>Players:
      <input type="text" id="modal-players-input" name="players" oninput="autoCompletePlayers(this)" />
      <div id="autocomplete-modal-list" class="autocomplete-items"></div>
    </label>
    <button type="submit">Save</button>
  </form>
</div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js "></script>
<script>
  const imageBounds = [[0, 0], [6080, 6080]];
  const imageUrl = 'map.webp';
  const GIST_ID = '5c5b1173184b3389531fe6235001b800';
  const GITHUB_TOKEN = localStorage.getItem('gh_token');
  const FILE_NAME = 'rising.json';

  let currentMarker = null;
  let currentLatLng = null;
  let activePlayers = [];
  let allPlayers = [];

  const map = L.map('map', {
    crs: L.CRS.Simple,
    minZoom: -3,
    maxZoom: 2,
    zoomSnap: 0,
    maxBoundsViscosity: 1,
    maxBounds: [[0, 0], [6080, 8080]],
    wheelPxPerZoomLevel: 20
  });

  L.imageOverlay(imageUrl, imageBounds).addTo(map);
  map.fitBounds(imageBounds);

  setTimeout(() => map.invalidateSize(), 200);

  const markerListContainer = document.getElementById('markersContainer');
  const modal = document.getElementById('modal');
  const markerForm = document.getElementById('markerForm');

  function getIcon(level, matches = 0) {
    return new L.Icon({
      iconUrl: ['V','IV','III','II','I'].includes(level?.toUpperCase())
              ? `${level.toUpperCase()}.svg`
              : 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
      className: 'icon-level-' + matches,
      iconSize: [25, 41],
      iconAnchor: [12, 41],
      popupAnchor: [1, -34],
      shadowSize: [41, 41]
    });
  }

  function showModal(latlng, markerData = null) {
    currentLatLng = latlng;
    currentMarker = markerData ? markerData.marker : null;

    markerForm.level.value = markerData?.level || 'I';
    markerForm.title.value = markerData?.title || '';
    markerForm.description.value = markerData?.description || '';
    document.getElementById('modal-players-input').value = markerData?.players?.join(', ') || '';

    modal.style.display = 'flex';
    setTimeout(() => map.invalidateSize(), 200);
  }

  markerForm.addEventListener('submit', function(e) {
    e.preventDefault();
    const data = {
      level: this.level.value,
      title: this.title.value.trim(),
      description: this.description.value.trim(),
      players: parsePlayers(document.getElementById('modal-players-input').value),
      lat: currentLatLng.lat,
      lng: currentLatLng.lng
    };

    if (currentMarker) {
      updateMarker(currentMarker, data);
    } else {
      addMarker(data);
    }

    modal.style.display = 'none';
    applyPlayerFilter();
    saveMarkersToGist();
  });

  document.querySelector('.close-modal').addEventListener('click', () => {
    modal.style.display = 'none';
    map.invalidateSize();
  });

  function parsePlayers(str) {
    return str.split(',')
            .map(p => p.trim())
            .filter(Boolean);
  }

  function addMarker(data) {
    if (typeof data.lat !== 'number' || typeof data.lng !== 'number') {
      console.error("Некорректные координаты метки", data);
      return;
    }

    const marker = L.marker([data.lat, data.lng], {
      icon: getIcon(data.level),
      draggable: true,
      data: data
    }).addTo(map);

    createPopup(marker, data);

    marker.on('dragend', () => {
      const latlng = marker.getLatLng();
      marker.options.data.lat = latlng.lat;
      marker.options.data.lng = latlng.lng;
      saveMarkersToGist();
    });

    return marker;
  }

  function updateMarker(marker, newData) {
    marker.setIcon(getIcon(newData.level));
    marker.options.data = {
      level: newData.level,
      title: newData.title,
      description: newData.description,
      players: newData.players,
      lat: marker.getLatLng().lat,
      lng: marker.getLatLng().lng
    };
    createPopup(marker, newData);
    saveMarkersToGist();
  }

  function createPopup(marker, data) {
    const popupContent = `
      <div><strong>${data.title}</strong></div>
      <div>${data.description}</div>
      Players: ${data.players.join(', ') || '-'}<br>
      <button onclick="editMarker(${data.lat}, ${data.lng})">Edit</button>
      <button onclick="removeMarker(this, ${data.lat}, ${data.lng})">Delete</button>
    `;
    marker.bindPopup(popupContent);
  }

  window.editMarker = function(lat, lng) {
    map.eachLayer(layer => {
      if (layer instanceof L.Marker) {
        const ll = layer.getLatLng();
        if (ll.lat === lat && ll.lng === lng) {
          const data = layer.options.data;
          showModal(L.latLng(lat, lng), {
            marker: layer,
            level: data.level,
            title: data.title,
            description: data.description,
            players: data.players
          });
        }
      }
    });
  };

  window.removeMarker = function(btn, lat, lng) {
    map.eachLayer(layer => {
      if (layer instanceof L.Marker) {
        const ll = layer.getLatLng();
        if (ll.lat === lat && ll.lng === lng) {
          map.removeLayer(layer);
        }
      }
    });
    saveMarkersToGist();

    const parent = btn.closest('.marker-item');
    if (parent) parent.remove();
  };

  function getMarkersFromMap() {
    const markers = [];
    map.eachLayer(layer => {
      if (layer instanceof L.Marker) {
        const d = layer.options.data;
        markers.push(d);
      }
    });
    return markers;
  }

  function renderMarkerList() {
    markerListContainer.innerHTML = '';
    const markers = getMarkersFromMap();

    markers.forEach(m => {
      const div = document.createElement('div');
      div.className = 'marker-item';
      div.innerHTML = `
        <div class="marker-level">[ ${m.level} ] <span class="marker-title">${m.title}</span></div>
        <div class="marker-players">Players:
          ${m.players.map(p => {
        const isMatch = activePlayers.includes(p);
        return isMatch ? `<span class="matched">${p}</span>` : p;
      }).join(', ') || '-'}
        </div>`;
      div.onclick = () => {
        map.flyTo([m.lat, m.lng], -1);
        map.eachLayer(layer => {
          if (layer instanceof L.Marker) {
            const ll = layer.getLatLng();
            if (ll.lat === m.lat && ll.lng === m.lng) {
              layer.openPopup();
            }
          }
        });
      };
      markerListContainer.appendChild(div);
    });
  }

  async function saveMarkersToGist() {
    const markers = getMarkersFromMap();

    if (!GITHUB_TOKEN) {
      localStorage.setItem('mapMarkers', JSON.stringify(markers));
      return;
    }

    const payload = {
      description: 'V: RISING Map Markers',
      public: false,
      files: {}
    };

    payload.files[FILE_NAME] = {
      content: JSON.stringify(markers, null, 2)
    };

    try {
      const res = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
        method: 'PATCH',
        headers: {
          Authorization: `token ${GITHUB_TOKEN}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(payload)
      });

      if (res.status === 200) {
        renderMarkerList();
      }
    } catch (e) {
      console.error('Ошибка сохранения в Gist', e);
    }
  }

  async function loadMarkersFromGist() {
    try {
      const res = await fetch(`https://api.github.com/gists/${GIST_ID}`);
      if (res.ok) {
        const json = await res.json();
        const raw = json.files[FILE_NAME]?.content;
        if (raw) {
          const markers = JSON.parse(raw);
          markers.forEach(m => {
            if (typeof m.lat === 'number' && typeof m.lng === 'number') {
              addMarker(m);
            }
          });
        }
      }
    } catch (e) {
      console.error('Не удалось загрузить из Gist');
    }

    const localMarkers = JSON.parse(localStorage.getItem('mapMarkers'));
    if (localMarkers) {
      localMarkers.forEach(m => {
        if (typeof m.lat === 'number' && typeof m.lng === 'number') {
          addMarker(m);
        }
      });
    }

    renderMarkerList();
  }

  function autoApplyFilter() {
    applyPlayerFilter();
  }

  function applyPlayerFilter() {
    activePlayers = parsePlayers(document.getElementById('playerNamesInput').value);
    map.eachLayer(layer => {
      if (layer instanceof L.Marker) {
        const markerData = layer.options.data;
        const matches = markerData.players.filter(p => activePlayers.includes(p));
        layer.setIcon(getIcon(markerData.level, matches.length));
      }
    });
    renderMarkerList();
  }

  map.on('click', e => showModal(e.latlng));
  window.addEventListener('load', () => {
    loadMarkersFromGist();
    loadPlayerList();
    window.addEventListener('resize', () => map.invalidateSize());
  });

  async function loadPlayerList() {
    try {
      allPlayers = (await Promise.all([
        fetch('https://api.battlemetrics.com/servers/33218693/relationships/leaderboards/time?page[size]=100&page[offset]=0&page[rel]=prev&filter[period]=2025-04-16T00:00:00.000Z:2025-05-16T00:00:00.000Z').then(r => r.json().then(j => j.data.map(p => p.attributes.name))),
        fetch('https://api.battlemetrics.com/servers/33218693/relationships/leaderboards/time?page[size]=100&page[offset]=100&page[rel]=prev&filter[period]=2025-04-16T00:00:00.000Z:2025-05-16T00:00:00.000Z').then(r => r.json().then(j => j.data.map(p => p.attributes.name)))
      ])).flat()
    } catch (e) {
      console.error('Ошибка загрузки списка игроков', e);
    }
  }

  function autoCompletePlayers(inputElement) {
    const val = inputElement.value.trim();
    const container = inputElement.nextElementSibling;
    container.innerHTML = "";

    if (!val) return;

    const currentList = val.split(',').map(s => s.trim());
    const last = currentList.pop().toLowerCase();

    const matches = allPlayers.filter(p =>
            p.toLowerCase().startsWith(last) && !currentList.map(x => x.toLowerCase()).includes(p.toLowerCase())
    );

    matches.forEach(match => {
      const item = document.createElement("div");
      item.textContent = match;
      item.onclick = () => {
        const newValue = [...currentList, match].join(", ");
        inputElement.value = newValue + ", ";
        inputElement.focus();
        container.innerHTML = "";
        applyPlayerFilter();
      };
      container.appendChild(item);
    });
  }

  document.addEventListener("click", function(e) {
    const list = document.getElementById("autocomplete-list");
    const modalList = document.getElementById("autocomplete-modal-list");
    if (!e.target.closest('#playerNamesInput')) list.innerHTML = "";
    if (!e.target.closest('#modal-players-input')) modalList.innerHTML = "";
  });

</script>
</body>
</html>